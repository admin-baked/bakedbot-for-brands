/**
 * Vibe GitHub Integration
 *
 * Pushes generated code to GitHub repositories for version control and deployment.
 * Uses Octokit (GitHub REST API) to create repos and push code.
 */

import { Octokit } from '@octokit/rest';
import { logger } from '@/lib/logger';
import type { VibeCodeProject } from '@/types/vibe-code';

interface GitHubPushOptions {
  project: VibeCodeProject;
  userGitHubToken: string; // User's personal access token
  repoName?: string; // Optional custom repo name
  isPrivate?: boolean; // Make repo private
}

interface GitHubPushResult {
  success: boolean;
  repoUrl?: string;
  cloneUrl?: string;
  error?: string;
}

/**
 * Create GitHub repository and push code
 */
export async function pushToGitHub(
  options: GitHubPushOptions
): Promise<GitHubPushResult> {
  try {
    logger.info('[VIBE-GITHUB] Pushing project to GitHub', {
      projectId: options.project.id,
      projectName: options.project.name,
    });

    // Initialize Octokit with user's token
    const octokit = new Octokit({
      auth: options.userGitHubToken,
    });

    // Get authenticated user
    const { data: user } = await octokit.users.getAuthenticated();
    logger.info('[VIBE-GITHUB] Authenticated as', { login: user.login });

    // Generate repo name
    const repoName =
      options.repoName ||
      `${options.project.name.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;

    // Create repository
    const { data: repo } = await octokit.repos.createForAuthenticatedUser({
      name: repoName,
      description: `${options.project.description} - Generated by BakedBot Vibe IDE`,
      private: options.isPrivate !== false, // Default to private
      auto_init: true, // Initialize with README
    });

    logger.info('[VIBE-GITHUB] Repository created', {
      repoUrl: repo.html_url,
      cloneUrl: repo.clone_url,
    });

    // Get default branch (usually 'main' or 'master')
    const defaultBranch = repo.default_branch || 'main';

    // Get the SHA of the latest commit
    const { data: ref } = await octokit.git.getRef({
      owner: user.login,
      repo: repoName,
      ref: `heads/${defaultBranch}`,
    });
    const latestCommitSha = ref.object.sha;

    // Get the tree SHA of the latest commit
    const { data: commit } = await octokit.git.getCommit({
      owner: user.login,
      repo: repoName,
      commit_sha: latestCommitSha,
    });
    const baseTreeSha = commit.tree.sha;

    // Create blobs for all files
    const fileBlobs = await Promise.all(
      options.project.files.map(async (file) => {
        const { data: blob } = await octokit.git.createBlob({
          owner: user.login,
          repo: repoName,
          content: Buffer.from(file.content).toString('base64'),
          encoding: 'base64',
        });

        return {
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          sha: blob.sha,
        };
      })
    );

    logger.info('[VIBE-GITHUB] Created blobs for files', {
      count: fileBlobs.length,
    });

    // Create a new tree
    const { data: newTree } = await octokit.git.createTree({
      owner: user.login,
      repo: repoName,
      base_tree: baseTreeSha,
      tree: fileBlobs,
    });

    // Create a commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner: user.login,
      repo: repoName,
      message: `Initial commit from BakedBot Vibe IDE\n\nProject: ${options.project.name}\nGenerated: ${new Date().toISOString()}`,
      tree: newTree.sha,
      parents: [latestCommitSha],
    });

    // Update the reference
    await octokit.git.updateRef({
      owner: user.login,
      repo: repoName,
      ref: `heads/${defaultBranch}`,
      sha: newCommit.sha,
    });

    logger.info('[VIBE-GITHUB] Code pushed successfully', {
      commitSha: newCommit.sha,
    });

    // Add topics for discoverability
    await octokit.repos.replaceAllTopics({
      owner: user.login,
      repo: repoName,
      names: [
        'bakedbot',
        'vibe-ide',
        'dispensary',
        'cannabis',
        'nextjs',
        'ai-generated',
      ],
    });

    return {
      success: true,
      repoUrl: repo.html_url,
      cloneUrl: repo.clone_url,
    };
  } catch (error) {
    logger.error('[VIBE-GITHUB] Push failed', {
      error: error instanceof Error ? error.message : String(error),
    });

    // Parse GitHub API errors
    let errorMessage = 'Failed to push to GitHub';
    if (error instanceof Error) {
      if (error.message.includes('Bad credentials')) {
        errorMessage = 'Invalid GitHub token. Please check your credentials.';
      } else if (error.message.includes('name already exists')) {
        errorMessage = 'Repository name already exists. Try a different name.';
      } else {
        errorMessage = error.message;
      }
    }

    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Validate GitHub token
 */
export async function validateGitHubToken(
  token: string
): Promise<{ valid: boolean; username?: string; error?: string }> {
  try {
    const octokit = new Octokit({ auth: token });
    const { data: user } = await octokit.users.getAuthenticated();

    return {
      valid: true,
      username: user.login,
    };
  } catch (error) {
    logger.error('[VIBE-GITHUB] Token validation failed', { error });
    return {
      valid: false,
      error: 'Invalid GitHub token',
    };
  }
}

/**
 * List user's repositories (for choosing existing repo)
 */
export async function listUserRepos(
  token: string
): Promise<{ success: boolean; repos?: Array<{ name: string; url: string }>; error?: string }> {
  try {
    const octokit = new Octokit({ auth: token });

    const { data: repos } = await octokit.repos.listForAuthenticatedUser({
      sort: 'updated',
      per_page: 30,
    });

    return {
      success: true,
      repos: repos.map((repo) => ({
        name: repo.name,
        url: repo.html_url,
      })),
    };
  } catch (error) {
    logger.error('[VIBE-GITHUB] Failed to list repos', { error });
    return {
      success: false,
      error: 'Failed to fetch repositories',
    };
  }
}
