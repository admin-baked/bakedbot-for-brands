
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // CEO gets god-mode access. This is useful for admin tasks and debugging.
    // In production, you might replace this with a more granular role-based access control system.
    match /{document=**} {
      allow read, write: if request.auth != null && 
        request.auth.token.ceo == true;
    }

    // GUEST CHECKOUT:
    // This allows unauthenticated server actions to create orders for guests.
    // It's a trade-off for UX. The rule is now restricted to only allow the 'create'
    // operation, preventing anyone from reading, updating, or deleting guest orders.
    // A more secure long-term solution is to use Firebase Anonymous Auth.
    match /users/guest/orders/{orderId} {
      allow create: if true;
      // Deny all other operations
      allow read, update, delete: if false;

      match /orderItems/{itemId} {
        allow create: if true;
        allow read, update, delete: if false;
      }
    }
    
    // AUTHENTICATED USERS:
    // These rules ensure users can only access their own data.
    match /users/{userId} {
      // Allow any authenticated user to create their own user document on signup.
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // Allow users to read and write their own public profile document.
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // USER ORDERS: Users can only access their own orders.
      match /orders/{orderId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
        
        // USER ORDER ITEMS: Users can only access items within their own orders.
        match /orderItems/{itemId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }
    }

    // USER-PRIVATE:
    // This collection stores sensitive user data like API keys.
    // Only the user themselves can read or write their own private document.
    match /user-private/{userId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // PUBLIC DATA:
    // Products, locations, and reviews are generally public-read.
    match /products/{productId} {
      allow read: if true;
      
      // SECURE FEEDBACK:
      // Allow atomic increments for likes/dislikes, but disallow any other field updates.
      // This prevents users from, for example, changing a product's price.
      allow update: if (
        request.auth != null &&
        // Check that only 'likes' or 'dislikes' are being affected in the update.
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'dislikes']) &&
        (
          // Rule for liking a product: 'likes' must increment by 1, and 'dislikes' must not change.
          (
            request.resource.data.likes == resource.data.likes + 1 &&
            request.resource.data.dislikes == resource.data.dislikes
          ) ||
          // Rule for disliking a product: 'dislikes' must increment by 1, and 'likes' must not change.
          (
            request.resource.data.dislikes == resource.data.dislikes + 1 &&
            request.resource.data.likes == resource.data.likes
          )
        )
      );
      
      // REVIEWS SUBCOLLECTION
      match /reviews/{reviewId} {
          // Anyone can read a review.
          allow read: if true;
          // Any authenticated user can create a review.
          allow create: if request.auth != null;
      }
    }
    
    // SECURE COLLECTION GROUP QUERY:
    // This rule allows the 'reviews' collection group to be queried,
    // but ONLY if the query includes a 'where("productId", "==", productId)' clause.
    // This is critical for securely fetching all reviews for a specific product without
    // exposing a way to list all reviews across all products.
    match /{path=**}/reviews/{reviewId} {
      allow list: if "productId" in request.query.where;
    }
    
    // LOCATIONS: Publicly readable.
    match /locations/{locationId} {
      allow read: if true;
    }
  }
}
